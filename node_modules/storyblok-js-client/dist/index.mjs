var m = Object.defineProperty;
var T = (o, e, t) => e in o ? m(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var h = (o, e, t) => (T(o, typeof e != "symbol" ? e + "" : e, t), t);
function y(o) {
  return !(o !== o || o === 1 / 0 || o === -1 / 0);
}
function R(o, e, t) {
  if (!y(e))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!y(t))
    throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let r = [], n = 0;
  const i = function() {
    n++;
    const a = setTimeout(function() {
      n--, s.length > 0 && i(), r = r.filter(function(u) {
        return u !== a;
      });
    }, t);
    r.indexOf(a) < 0 && r.push(a);
    const c = s.shift();
    c.resolve(o.apply(c.self, c.args));
  }, l = function(...a) {
    const c = this;
    return new Promise(function(u, p) {
      s.push({
        resolve: u,
        reject: p,
        args: a,
        self: c
      }), n < e && i();
    });
  };
  return l.abort = function() {
    r.forEach(clearTimeout), r = [], s.forEach(function(a) {
      a.reject(function() {
        Error.call(this, "Throttled function aborted"), this.name = "AbortError";
      });
    }), s.length = 0;
  }, l;
}
const _ = function(o, e) {
  const t = {};
  for (const s in o) {
    const r = o[s];
    e.indexOf(s) > -1 && r !== null && (t[s] = r);
  }
  return t;
}, b = (o) => o === "email", w = () => ({
  singleTag: "hr"
}), P = () => ({
  tag: "blockquote"
}), x = () => ({
  tag: "ul"
}), $ = (o) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: o.attrs
    }
  ]
}), S = () => ({
  singleTag: "br"
}), E = (o) => ({
  tag: `h${o.attrs.level}`
}), C = (o) => ({
  singleTag: [
    {
      tag: "img",
      attrs: _(o.attrs, ["src", "alt", "title"])
    }
  ]
}), O = () => ({
  tag: "li"
}), M = () => ({
  tag: "ol"
}), H = () => ({
  tag: "p"
}), A = () => ({
  tag: "b"
}), L = () => ({
  tag: "strike"
}), U = () => ({
  tag: "u"
}), I = () => ({
  tag: "strong"
}), N = () => ({
  tag: "code"
}), q = () => ({
  tag: "i"
}), z = (o) => {
  const e = { ...o.attrs }, { linktype: t = "url" } = o.attrs;
  return b(t) && (e.href = `mailto:${e.href}`), e.anchor && (e.href = `${e.href}#${e.anchor}`, delete e.anchor), {
    tag: [
      {
        tag: "a",
        attrs: e
      }
    ]
  };
}, j = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: o.attrs
    }
  ]
}), F = {
  nodes: {
    horizontal_rule: w,
    blockquote: P,
    bullet_list: x,
    code_block: $,
    hard_break: S,
    heading: E,
    image: C,
    list_item: O,
    ordered_list: M,
    paragraph: H
  },
  marks: {
    bold: A,
    strike: L,
    underline: U,
    strong: I,
    code: N,
    italic: q,
    link: z,
    styled: j
  }
}, V = function(o) {
  const e = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, t = /[&<>"']/g, s = RegExp(t.source);
  return o && s.test(o) ? o.replace(t, (r) => e[r]) : o;
};
class k {
  constructor(e) {
    h(this, "marks");
    h(this, "nodes");
    e || (e = F), this.marks = e.marks || [], this.nodes = e.nodes || [];
  }
  addNode(e, t) {
    this.nodes[e] = t;
  }
  addMark(e, t) {
    this.marks[e] = t;
  }
  render(e) {
    if (e && e.content && Array.isArray(e.content)) {
      let t = "";
      return e.content.forEach((s) => {
        t += this.renderNode(s);
      }), t;
    }
    return console.warn(
      "The render method must receive an object with a content field, which is an array"
    ), "";
  }
  renderNode(e) {
    const t = [];
    e.marks && e.marks.forEach((r) => {
      const n = this.getMatchingMark(r);
      n && t.push(this.renderOpeningTag(n.tag));
    });
    const s = this.getMatchingNode(e);
    return s && s.tag && t.push(this.renderOpeningTag(s.tag)), e.content ? e.content.forEach((r) => {
      t.push(this.renderNode(r));
    }) : e.text ? t.push(V(e.text)) : s && s.singleTag ? t.push(this.renderTag(s.singleTag, " /")) : s && s.html && t.push(s.html), s && s.tag && t.push(this.renderClosingTag(s.tag)), e.marks && e.marks.slice(0).reverse().forEach((r) => {
      const n = this.getMatchingMark(r);
      n && t.push(this.renderClosingTag(n.tag));
    }), t.join("");
  }
  renderTag(e, t) {
    return e.constructor === String ? `<${e}${t}>` : e.map((r) => {
      if (r.constructor === String)
        return `<${r}${t}>`;
      {
        let n = `<${r.tag}`;
        if (r.attrs)
          for (const i in r.attrs) {
            const l = r.attrs[i];
            l !== null && (n += ` ${i}="${l}"`);
          }
        return `${n}${t}>`;
      }
    }).join("");
  }
  renderOpeningTag(e) {
    return this.renderTag(e, "");
  }
  renderClosingTag(e) {
    return e.constructor === String ? `</${e}>` : e.slice(0).reverse().map((s) => s.constructor === String ? `</${s}>` : `</${s.tag}>`).join("");
  }
  getMatchingNode(e) {
    const t = this.nodes[e.type];
    if (typeof t == "function")
      return t(e);
  }
  getMatchingMark(e) {
    const t = this.marks[e.type];
    if (typeof t == "function")
      return t(e);
  }
}
class v {
  constructor() {
    h(this, "isCDNUrl", (e = "") => e.indexOf("/cdn/") > -1);
    h(this, "getOptionsPage", (e, t = 25, s = 1) => ({
      ...e,
      per_page: t,
      page: s
    }));
    h(this, "delay", (e) => new Promise((t) => setTimeout(t, e)));
    h(this, "arrayFrom", (e = 0, t) => [...Array(e)].map(t));
    h(this, "range", (e = 0, t = e) => {
      const s = Math.abs(t - e) || 0, r = e < t ? 1 : -1;
      return this.arrayFrom(s, (n, i) => i * r + e);
    });
    h(this, "asyncMap", async (e, t) => Promise.all(e.map(t)));
    h(this, "flatMap", (e = [], t) => e.map(t).reduce((s, r) => [...s, ...r], []));
  }
  stringify(e, t, s) {
    const r = [];
    for (const n in e) {
      if (!Object.prototype.hasOwnProperty.call(e, n))
        continue;
      const i = e[n], l = s ? "" : encodeURIComponent(n);
      let a;
      typeof i == "object" ? a = this.stringify(
        i,
        t ? t + encodeURIComponent("[" + l + "]") : l,
        Array.isArray(i)
      ) : a = (t ? t + encodeURIComponent("[" + l + "]") : l) + "=" + encodeURIComponent(i), r.push(a);
    }
    return r.join("&");
  }
}
class J {
  constructor(e) {
    h(this, "baseURL");
    h(this, "timeout");
    h(this, "headers");
    h(this, "responseInterceptor");
    h(this, "fetch");
    h(this, "ejectInterceptor");
    h(this, "url");
    h(this, "parameters");
    this.baseURL = e.baseURL, this.headers = e.headers || [], this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = "", this.parameters = {};
  }
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], s = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((r) => {
      s.data = r;
    });
    for (const r of e.headers.entries())
      t[r[0]] = r[1];
    return s.headers = { ...t }, s.status = e.status, s.statusText = e.statusText, s;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, s = null;
    if (e === "get") {
      const a = new v();
      t = `${this.baseURL}${this.url}?${a.stringify(
        this.parameters
      )}`;
    } else
      s = JSON.stringify(this.parameters);
    const r = new URL(t), n = new AbortController(), { signal: i } = n;
    let l;
    this.timeout && (l = setTimeout(() => n.abort(), this.timeout));
    try {
      const a = await this.fetch(`${r}`, {
        method: e,
        headers: this.headers,
        body: s,
        signal: i
      });
      this.timeout && clearTimeout(l);
      const c = await this._responseHandler(a);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);
    } catch (a) {
      return {
        message: a
      };
    }
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((s, r) => {
      if (t.test(`${e.status}`))
        return s(e);
      const n = {
        message: new Error(e.statusText),
        status: e.status,
        response: e.data.error || e.data.slug
      };
      r(n);
    });
  }
}
let f = {};
const d = {};
class Q {
  constructor(e, t) {
    h(this, "client");
    h(this, "maxRetries");
    h(this, "throttle");
    h(this, "accessToken");
    h(this, "cache");
    h(this, "helpers");
    h(this, "relations");
    h(this, "links");
    h(this, "richTextResolver");
    h(this, "resolveNestedRelations");
    if (!t) {
      const n = e.region ? `-${e.region}` : "", i = e.https === !1 ? "http" : "https";
      e.oauthToken ? t = `${i}://api${n}.storyblok.com/v1` : t = `${i}://api${n}.storyblok.com/v2`;
    }
    const s = new Headers();
    s.set("Content-Type", "application/json"), s.set("Accept", "application/json"), s.forEach((n, i) => {
      e.headers && e.headers[i] && s.set(i, e.headers[i]);
    });
    let r = 5;
    e.oauthToken && (s.set("Authorization", e.oauthToken), r = 3), e.rateLimit && (r = e.rateLimit), e.richTextSchema ? this.richTextResolver = new k(e.richTextSchema) : this.richTextResolver = new k(), e.componentResolver && this.setComponentResolver(e.componentResolver), this.maxRetries = e.maxRetries, this.throttle = R(this.throttledRequest, r, 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.helpers = new v(), this.resolveNestedRelations = !1, this.client = new J({
      baseURL: t,
      timeout: e.timeout || 0,
      headers: s,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  setComponentResolver(e) {
    this.richTextResolver.addNode("blok", (t) => {
      let s = "";
      return t.attrs.body.forEach((r) => {
        s += e(r.component, r);
      }), {
        html: s
      };
    });
  }
  parseParams(e) {
    return e.version || (e.version = "published"), e.token || (e.token = this.getToken()), e.cv || (e.cv = d[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), e;
  }
  factoryParamOptions(e, t) {
    return this.helpers.isCDNUrl(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, s, r) {
    const n = this.factoryParamOptions(
      e,
      this.helpers.getOptionsPage(t, s, r)
    );
    return this.cacheResponse(e, n);
  }
  get(e, t) {
    t || (t = {});
    const s = `/${e}`, r = this.factoryParamOptions(s, t);
    return this.cacheResponse(s, r);
  }
  async getAll(e, t, s) {
    const r = (t == null ? void 0 : t.per_page) || 25, n = `/${e}`, i = n.split("/"), l = s || i[i.length - 1], a = 1, c = await this.makeRequest(n, t, r, a), u = c.total ? Math.ceil(c.total / r) : 1, p = await this.helpers.asyncMap(
      this.helpers.range(a, u),
      (g) => this.makeRequest(n, t, r, g + 1)
    );
    return this.helpers.flatMap(
      [c, ...p],
      (g) => Object.values(g.data[l])
    );
  }
  post(e, t) {
    const s = `/${e}`;
    return Promise.resolve(this.throttle("post", s, t));
  }
  put(e, t) {
    const s = `/${e}`;
    return Promise.resolve(this.throttle("put", s, t));
  }
  delete(e, t) {
    const s = `/${e}`;
    return Promise.resolve(this.throttle("delete", s, t));
  }
  getStories(e) {
    return this.get("cdn/stories", e);
  }
  getStory(e, t) {
    return this.get(`cdn/stories/${e}`, t);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t) {
    const s = e[t];
    s && s.fieldtype == "multilink" && s.linktype == "story" && typeof s.id == "string" && this.links[s.id] ? s.story = this._cleanCopy(this.links[s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[s.uuid] && (s.story = this._cleanCopy(this.links[s.uuid]));
  }
  _insertRelations(e, t, s) {
    if (s.indexOf(`${e.component}.${t}`) > -1) {
      if (typeof e[t] == "string")
        this.relations[e[t]] && (e[t] = this._cleanCopy(this.relations[e[t]]));
      else if (e[t] && e[t].constructor === Array) {
        const r = [];
        e[t].forEach((n) => {
          this.relations[n] && r.push(this._cleanCopy(this.relations[n]));
        }), e[t] = r;
      }
    }
  }
  iterateTree(e, t) {
    const s = (r) => {
      if (r != null) {
        if (r.constructor === Array)
          for (let n = 0; n < r.length; n++)
            s(r[n]);
        else if (r.constructor === Object) {
          if (r._stopResolving)
            return;
          for (const n in r)
            (r.component && r._uid || r.type === "link") && (this._insertRelations(
              r,
              n,
              t
            ), this._insertLinks(r, n)), s(r[n]);
        }
      }
    };
    s(e.content);
  }
  async resolveLinks(e, t) {
    let s = [];
    if (e.link_uuids) {
      const r = e.link_uuids.length, n = [], i = 50;
      for (let l = 0; l < r; l += i) {
        const a = Math.min(r, l + i);
        n.push(e.link_uuids.slice(l, a));
      }
      for (let l = 0; l < n.length; l++)
        (await this.getStories({
          per_page: i,
          language: t.language,
          version: t.version,
          by_uuids: n[l].join(",")
        })).data.stories.forEach(
          (c) => {
            s.push(c);
          }
        );
    } else
      s = e.links;
    s.forEach((r) => {
      this.links[r.uuid] = { ...r, _stopResolving: !0 };
    });
  }
  async resolveRelations(e, t) {
    let s = [];
    if (e.rel_uuids) {
      const r = e.rel_uuids.length, n = [], i = 50;
      for (let l = 0; l < r; l += i) {
        const a = Math.min(r, l + i);
        n.push(e.rel_uuids.slice(l, a));
      }
      for (let l = 0; l < n.length; l++)
        (await this.getStories({
          per_page: i,
          language: t.language,
          version: t.version,
          by_uuids: n[l].join(",")
        })).data.stories.forEach((c) => {
          s.push(c);
        });
    } else
      s = e.rels;
    s && s.length > 0 && s.forEach((r) => {
      this.relations[r.uuid] = { ...r, _stopResolving: !0 };
    });
  }
  async resolveStories(e, t) {
    var r, n;
    let s = [];
    if (typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (s = t.resolve_relations.split(",")), await this.resolveRelations(e, t)), t.resolve_links && ["1", "story", "url"].indexOf(t.resolve_links) > -1 && ((r = e.links) != null && r.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t), this.resolveNestedRelations)
      for (const i in this.relations)
        this.iterateTree(this.relations[i], s);
    e.story ? this.iterateTree(e.story, s) : e.stories.forEach((i) => {
      this.iterateTree(i, s);
    });
  }
  async cacheResponse(e, t, s) {
    const r = this.helpers.stringify({ url: e, params: t }), n = this.cacheProvider();
    if (this.cache.clear === "auto" && t.version === "draft" && await this.flushCache(), t.version === "published" && e != "/cdn/spaces/me") {
      const i = await n.get(r);
      if (i)
        return Promise.resolve(i);
    }
    return new Promise((i, l) => {
      try {
        (async () => {
          var u;
          const a = await this.throttle("get", e, t);
          let c = { data: a.data, headers: a.headers };
          if ((u = a.headers) != null && u["per-page"] && (c = Object.assign({}, c, {
            perPage: a.headers["per-page"] ? parseInt(a.headers["per-page"]) : 0,
            total: a.headers["per-page"] ? parseInt(a.headers.total) : 0
          })), a.status != 200)
            return l(a);
          (c.data.story || c.data.stories) && await this.resolveStories(c.data, t), t.version === "published" && e != "/cdn/spaces/me" && await n.set(r, c), c.data.cv && t.token && (t.version == "draft" && d[t.token] != c.data.cv && await this.flushCache(), d[t.token] = c.data.cv), i(c);
        })();
      } catch {
      }
    });
  }
  throttledRequest(e, t, s) {
    return this.client[e](t, s);
  }
  cacheVersions() {
    return d;
  }
  cacheVersion() {
    return d[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (d[this.accessToken] = e);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(f[e]);
          },
          getAll() {
            return Promise.resolve(f);
          },
          set(e, t) {
            return f[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return f = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom)
          return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve(void 0);
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this;
  }
}
export {
  k as RichtextResolver,
  F as RichtextSchema,
  J as SbFetch,
  v as SbHelpers,
  Q as default
};
