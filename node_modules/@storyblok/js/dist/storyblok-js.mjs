let k = !1;
const v = [], w = (n) => new Promise((t, e) => {
  if (typeof window > "u" || (window.storyblokRegisterEvent = (r) => {
    if (window.location === window.parent.location) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    k ? r() : v.push(r);
  }, document.getElementById("storyblok-javascript-bridge")))
    return;
  const s = document.createElement("script");
  s.async = !0, s.src = n, s.id = "storyblok-javascript-bridge", s.onerror = (r) => e(r), s.onload = (r) => {
    v.forEach((o) => o()), k = !0, t(r);
  }, document.getElementsByTagName("head")[0].appendChild(s);
});
var $ = Object.defineProperty, P = (n, t, e) => t in n ? $(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e, c = (n, t, e) => (P(n, typeof t != "symbol" ? t + "" : t, e), e);
function b(n) {
  return !(n !== n || n === 1 / 0 || n === -1 / 0);
}
function j(n, t, e) {
  if (!b(t))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!b(e))
    throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let r = [], o = 0;
  const i = function() {
    o++;
    const l = setTimeout(function() {
      o--, s.length > 0 && i(), r = r.filter(function(u) {
        return u !== l;
      });
    }, e);
    r.indexOf(l) < 0 && r.push(l);
    const h = s.shift();
    h.resolve(n.apply(h.self, h.args));
  }, a = function(...l) {
    const h = this;
    return new Promise(function(u, f) {
      s.push({
        resolve: u,
        reject: f,
        args: l,
        self: h
      }), o < t && i();
    });
  };
  return a.abort = function() {
    r.forEach(clearTimeout), r = [], s.forEach(function(l) {
      l.reject(function() {
        Error.call(this, "Throttled function aborted"), this.name = "AbortError";
      });
    }), s.length = 0;
  }, a;
}
const x = function(n, t) {
  const e = {};
  for (const s in n) {
    const r = n[s];
    t.indexOf(s) > -1 && r !== null && (e[s] = r);
  }
  return e;
}, E = (n) => n === "email", S = () => ({
  singleTag: "hr"
}), O = () => ({
  tag: "blockquote"
}), C = () => ({
  tag: "ul"
}), I = (n) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: n.attrs
    }
  ]
}), A = () => ({
  singleTag: "br"
}), N = (n) => ({
  tag: `h${n.attrs.level}`
}), M = (n) => ({
  singleTag: [
    {
      tag: "img",
      attrs: x(n.attrs, ["src", "alt", "title"])
    }
  ]
}), L = () => ({
  tag: "li"
}), U = () => ({
  tag: "ol"
}), H = () => ({
  tag: "p"
}), B = () => ({
  tag: "b"
}), q = () => ({
  tag: "strike"
}), D = () => ({
  tag: "u"
}), J = () => ({
  tag: "strong"
}), F = () => ({
  tag: "code"
}), V = () => ({
  tag: "i"
}), z = (n) => {
  const t = { ...n.attrs }, { linktype: e = "url" } = n.attrs;
  return E(e) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), {
    tag: [
      {
        tag: "a",
        attrs: t
      }
    ]
  };
}, Y = (n) => ({
  tag: [
    {
      tag: "span",
      attrs: n.attrs
    }
  ]
}), K = {
  nodes: {
    horizontal_rule: S,
    blockquote: O,
    bullet_list: C,
    code_block: I,
    hard_break: A,
    heading: N,
    image: M,
    list_item: L,
    ordered_list: U,
    paragraph: H
  },
  marks: {
    bold: B,
    strike: q,
    underline: D,
    strong: J,
    code: F,
    italic: V,
    link: z,
    styled: Y
  }
}, Q = function(n) {
  const t = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, e = /[&<>"']/g, s = RegExp(e.source);
  return n && s.test(n) ? n.replace(e, (r) => t[r]) : n;
};
class g {
  constructor(t) {
    c(this, "marks"), c(this, "nodes"), t || (t = K), this.marks = t.marks || [], this.nodes = t.nodes || [];
  }
  addNode(t, e) {
    this.nodes[t] = e;
  }
  addMark(t, e) {
    this.marks[t] = e;
  }
  render(t) {
    if (t && t.content && Array.isArray(t.content)) {
      let e = "";
      return t.content.forEach((s) => {
        e += this.renderNode(s);
      }), e;
    }
    return console.warn(
      "The render method must receive an object with a content field, which is an array"
    ), "";
  }
  renderNode(t) {
    const e = [];
    t.marks && t.marks.forEach((r) => {
      const o = this.getMatchingMark(r);
      o && e.push(this.renderOpeningTag(o.tag));
    });
    const s = this.getMatchingNode(t);
    return s && s.tag && e.push(this.renderOpeningTag(s.tag)), t.content ? t.content.forEach((r) => {
      e.push(this.renderNode(r));
    }) : t.text ? e.push(Q(t.text)) : s && s.singleTag ? e.push(this.renderTag(s.singleTag, " /")) : s && s.html && e.push(s.html), s && s.tag && e.push(this.renderClosingTag(s.tag)), t.marks && t.marks.slice(0).reverse().forEach((r) => {
      const o = this.getMatchingMark(r);
      o && e.push(this.renderClosingTag(o.tag));
    }), e.join("");
  }
  renderTag(t, e) {
    return t.constructor === String ? `<${t}${e}>` : t.map((s) => {
      if (s.constructor === String)
        return `<${s}${e}>`;
      {
        let r = `<${s.tag}`;
        if (s.attrs)
          for (const o in s.attrs) {
            const i = s.attrs[o];
            i !== null && (r += ` ${o}="${i}"`);
          }
        return `${r}${e}>`;
      }
    }).join("");
  }
  renderOpeningTag(t) {
    return this.renderTag(t, "");
  }
  renderClosingTag(t) {
    return t.constructor === String ? `</${t}>` : t.slice(0).reverse().map((e) => e.constructor === String ? `</${e}>` : `</${e.tag}>`).join("");
  }
  getMatchingNode(t) {
    const e = this.nodes[t.type];
    if (typeof e == "function")
      return e(t);
  }
  getMatchingMark(t) {
    const e = this.marks[t.type];
    if (typeof e == "function")
      return e(t);
  }
}
class T {
  constructor() {
    c(this, "isCDNUrl", (t = "") => t.indexOf("/cdn/") > -1), c(this, "getOptionsPage", (t, e = 25, s = 1) => ({
      ...t,
      per_page: e,
      page: s
    })), c(this, "delay", (t) => new Promise((e) => setTimeout(e, t))), c(this, "arrayFrom", (t = 0, e) => [...Array(t)].map(e)), c(this, "range", (t = 0, e = t) => {
      const s = Math.abs(e - t) || 0, r = t < e ? 1 : -1;
      return this.arrayFrom(s, (o, i) => i * r + t);
    }), c(this, "asyncMap", async (t, e) => Promise.all(t.map(e))), c(this, "flatMap", (t = [], e) => t.map(e).reduce((s, r) => [...s, ...r], []));
  }
  stringify(t, e, s) {
    const r = [];
    for (const o in t) {
      if (!Object.prototype.hasOwnProperty.call(t, o))
        continue;
      const i = t[o], a = s ? "" : encodeURIComponent(o);
      let l;
      typeof i == "object" ? l = this.stringify(
        i,
        e ? e + encodeURIComponent("[" + a + "]") : a,
        Array.isArray(i)
      ) : l = (e ? e + encodeURIComponent("[" + a + "]") : a) + "=" + encodeURIComponent(i), r.push(l);
    }
    return r.join("&");
  }
}
class G {
  constructor(t) {
    c(this, "baseURL"), c(this, "timeout"), c(this, "headers"), c(this, "responseInterceptor"), c(this, "fetch"), c(this, "ejectInterceptor"), c(this, "url"), c(this, "parameters"), this.baseURL = t.baseURL, this.headers = t.headers || [], this.timeout = t != null && t.timeout ? t.timeout * 1e3 : 0, this.responseInterceptor = t.responseInterceptor, this.fetch = (...e) => t.fetch ? t.fetch(...e) : fetch(...e), this.ejectInterceptor = !1, this.url = "", this.parameters = {};
  }
  get(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("get");
  }
  post(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("post");
  }
  put(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("put");
  }
  delete(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("delete");
  }
  async _responseHandler(t) {
    const e = [], s = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    t.status !== 204 && await t.json().then((r) => {
      s.data = r;
    });
    for (const r of t.headers.entries())
      e[r[0]] = r[1];
    return s.headers = { ...e }, s.status = t.status, s.statusText = t.statusText, s;
  }
  async _methodHandler(t) {
    let e = `${this.baseURL}${this.url}`, s = null;
    if (t === "get") {
      const l = new T();
      e = `${this.baseURL}${this.url}?${l.stringify(
        this.parameters
      )}`;
    } else
      s = JSON.stringify(this.parameters);
    const r = new URL(e), o = new AbortController(), { signal: i } = o;
    let a;
    this.timeout && (a = setTimeout(() => o.abort(), this.timeout));
    try {
      const l = await this.fetch(`${r}`, {
        method: t,
        headers: this.headers,
        body: s,
        signal: i
      });
      this.timeout && clearTimeout(a);
      const h = await this._responseHandler(l);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(h)) : this._statusHandler(h);
    } catch (l) {
      return {
        message: l
      };
    }
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  _statusHandler(t) {
    const e = /20[0-6]/g;
    return new Promise((s, r) => {
      if (e.test(`${t.status}`))
        return s(t);
      const o = {
        message: new Error(t.statusText),
        status: t.status,
        response: t.data.error || t.data.slug
      };
      r(o);
    });
  }
}
let p = {};
const d = {};
class W {
  constructor(t, e) {
    if (c(this, "client"), c(this, "maxRetries"), c(this, "throttle"), c(this, "accessToken"), c(this, "cache"), c(this, "helpers"), c(this, "relations"), c(this, "links"), c(this, "richTextResolver"), c(this, "resolveNestedRelations"), !e) {
      const o = t.region ? `-${t.region}` : "", i = t.https === !1 ? "http" : "https";
      t.oauthToken ? e = `${i}://api${o}.storyblok.com/v1` : e = `${i}://api${o}.storyblok.com/v2`;
    }
    const s = new Headers();
    s.set("Content-Type", "application/json"), s.set("Accept", "application/json"), s.forEach((o, i) => {
      t.headers && t.headers[i] && s.set(i, t.headers[i]);
    });
    let r = 5;
    t.oauthToken && (s.set("Authorization", t.oauthToken), r = 3), t.rateLimit && (r = t.rateLimit), t.richTextSchema ? this.richTextResolver = new g(t.richTextSchema) : this.richTextResolver = new g(), t.componentResolver && this.setComponentResolver(t.componentResolver), this.maxRetries = t.maxRetries, this.throttle = j(this.throttledRequest, r, 1e3), this.accessToken = t.accessToken || "", this.relations = {}, this.links = {}, this.cache = t.cache || { clear: "manual" }, this.helpers = new T(), this.resolveNestedRelations = !1, this.client = new G({
      baseURL: e,
      timeout: t.timeout || 0,
      headers: s,
      responseInterceptor: t.responseInterceptor,
      fetch: t.fetch
    });
  }
  setComponentResolver(t) {
    this.richTextResolver.addNode("blok", (e) => {
      let s = "";
      return e.attrs.body.forEach((r) => {
        s += t(r.component, r);
      }), {
        html: s
      };
    });
  }
  parseParams(t) {
    return t.version || (t.version = "published"), t.token || (t.token = this.getToken()), t.cv || (t.cv = d[t.token]), Array.isArray(t.resolve_relations) && (t.resolve_relations = t.resolve_relations.join(",")), t;
  }
  factoryParamOptions(t, e) {
    return this.helpers.isCDNUrl(t) ? this.parseParams(e) : e;
  }
  makeRequest(t, e, s, r) {
    const o = this.factoryParamOptions(
      t,
      this.helpers.getOptionsPage(e, s, r)
    );
    return this.cacheResponse(t, o);
  }
  get(t, e) {
    e || (e = {});
    const s = `/${t}`, r = this.factoryParamOptions(s, e);
    return this.cacheResponse(s, r);
  }
  async getAll(t, e, s) {
    const r = (e == null ? void 0 : e.per_page) || 25, o = `/${t}`, i = o.split("/"), a = s || i[i.length - 1], l = 1, h = await this.makeRequest(o, e, r, l), u = h.total ? Math.ceil(h.total / r) : 1, f = await this.helpers.asyncMap(
      this.helpers.range(l, u),
      (m) => this.makeRequest(o, e, r, m + 1)
    );
    return this.helpers.flatMap(
      [h, ...f],
      (m) => Object.values(m.data[a])
    );
  }
  post(t, e) {
    const s = `/${t}`;
    return Promise.resolve(this.throttle("post", s, e));
  }
  put(t, e) {
    const s = `/${t}`;
    return Promise.resolve(this.throttle("put", s, e));
  }
  delete(t, e) {
    const s = `/${t}`;
    return Promise.resolve(this.throttle("delete", s, e));
  }
  getStories(t) {
    return this.get("cdn/stories", t);
  }
  getStory(t, e) {
    return this.get(`cdn/stories/${t}`, e);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _cleanCopy(t) {
    return JSON.parse(JSON.stringify(t));
  }
  _insertLinks(t, e) {
    const s = t[e];
    s && s.fieldtype == "multilink" && s.linktype == "story" && typeof s.id == "string" && this.links[s.id] ? s.story = this._cleanCopy(this.links[s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[s.uuid] && (s.story = this._cleanCopy(this.links[s.uuid]));
  }
  _insertRelations(t, e, s) {
    if (s.indexOf(`${t.component}.${e}`) > -1) {
      if (typeof t[e] == "string")
        this.relations[t[e]] && (t[e] = this._cleanCopy(this.relations[t[e]]));
      else if (t[e] && t[e].constructor === Array) {
        const r = [];
        t[e].forEach((o) => {
          this.relations[o] && r.push(this._cleanCopy(this.relations[o]));
        }), t[e] = r;
      }
    }
  }
  iterateTree(t, e) {
    const s = (r) => {
      if (r != null) {
        if (r.constructor === Array)
          for (let o = 0; o < r.length; o++)
            s(r[o]);
        else if (r.constructor === Object) {
          if (r._stopResolving)
            return;
          for (const o in r)
            (r.component && r._uid || r.type === "link") && (this._insertRelations(
              r,
              o,
              e
            ), this._insertLinks(r, o)), s(r[o]);
        }
      }
    };
    s(t.content);
  }
  async resolveLinks(t, e) {
    let s = [];
    if (t.link_uuids) {
      const r = t.link_uuids.length, o = [], i = 50;
      for (let a = 0; a < r; a += i) {
        const l = Math.min(r, a + i);
        o.push(t.link_uuids.slice(a, l));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: i,
          language: e.language,
          version: e.version,
          by_uuids: o[a].join(",")
        })).data.stories.forEach(
          (l) => {
            s.push(l);
          }
        );
    } else
      s = t.links;
    s.forEach((r) => {
      this.links[r.uuid] = { ...r, _stopResolving: !0 };
    });
  }
  async resolveRelations(t, e) {
    let s = [];
    if (t.rel_uuids) {
      const r = t.rel_uuids.length, o = [], i = 50;
      for (let a = 0; a < r; a += i) {
        const l = Math.min(r, a + i);
        o.push(t.rel_uuids.slice(a, l));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: i,
          language: e.language,
          version: e.version,
          by_uuids: o[a].join(",")
        })).data.stories.forEach((l) => {
          s.push(l);
        });
    } else
      s = t.rels;
    s && s.length > 0 && s.forEach((r) => {
      this.relations[r.uuid] = { ...r, _stopResolving: !0 };
    });
  }
  async resolveStories(t, e) {
    var s, r;
    let o = [];
    if (typeof e.resolve_relations < "u" && e.resolve_relations.length > 0 && (typeof e.resolve_relations == "string" && (o = e.resolve_relations.split(",")), await this.resolveRelations(t, e)), e.resolve_links && ["1", "story", "url"].indexOf(e.resolve_links) > -1 && ((s = t.links) != null && s.length || (r = t.link_uuids) != null && r.length) && await this.resolveLinks(t, e), this.resolveNestedRelations)
      for (const i in this.relations)
        this.iterateTree(this.relations[i], o);
    t.story ? this.iterateTree(t.story, o) : t.stories.forEach((i) => {
      this.iterateTree(i, o);
    });
  }
  async cacheResponse(t, e, s) {
    const r = this.helpers.stringify({ url: t, params: e }), o = this.cacheProvider();
    if (this.cache.clear === "auto" && e.version === "draft" && await this.flushCache(), e.version === "published" && t != "/cdn/spaces/me") {
      const i = await o.get(r);
      if (i)
        return Promise.resolve(i);
    }
    return new Promise((i, a) => {
      try {
        (async () => {
          var l;
          const h = await this.throttle("get", t, e);
          let u = { data: h.data, headers: h.headers };
          if ((l = h.headers) != null && l["per-page"] && (u = Object.assign({}, u, {
            perPage: h.headers["per-page"] ? parseInt(h.headers["per-page"]) : 0,
            total: h.headers["per-page"] ? parseInt(h.headers.total) : 0
          })), h.status != 200)
            return a(h);
          (u.data.story || u.data.stories) && await this.resolveStories(u.data, e), e.version === "published" && t != "/cdn/spaces/me" && await o.set(r, u), u.data.cv && e.token && (e.version == "draft" && d[e.token] != u.data.cv && await this.flushCache(), d[e.token] = u.data.cv), i(u);
        })();
      } catch {
      }
    });
  }
  throttledRequest(t, e, s) {
    return this.client[t](e, s);
  }
  cacheVersions() {
    return d;
  }
  cacheVersion() {
    return d[this.accessToken];
  }
  setCacheVersion(t) {
    this.accessToken && (d[this.accessToken] = t);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(t) {
            return Promise.resolve(p[t]);
          },
          getAll() {
            return Promise.resolve(p);
          },
          set(t, e) {
            return p[t] = e, Promise.resolve(void 0);
          },
          flush() {
            return p = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom)
          return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve(void 0);
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this;
  }
}
const X = (n = {}) => {
  const { apiOptions: t } = n;
  if (!t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new W(t) };
}, Z = (n) => {
  if (typeof n != "object" || typeof n._editable > "u")
    return {};
  const t = JSON.parse(
    n._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
  );
  return {
    "data-blok-c": JSON.stringify(t),
    "data-blok-uid": t.id + "-" + t.uid
  };
};
let y;
const R = "https://app.storyblok.com/f/storyblok-v2-latest.js", tt = (n, t, e = {}) => {
  if (!(typeof window > "u")) {
    if (typeof window.storyblokRegisterEvent > "u") {
      console.error(
        "Storyblok Bridge is disabled. Please enable it to use it. Read https://github.com/storyblok/storyblok-js"
      );
      return;
    }
    if (!n) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(e).on(["input", "published", "change"], (r) => {
        r.action === "input" && r.story.id === n ? t(r.story) : (r.action === "change" || r.action === "published") && r.storyId === n && window.location.reload();
      });
    });
  }
}, et = (n = {}) => {
  const {
    bridge: t,
    accessToken: e,
    use: s = [],
    apiOptions: r = {},
    richText: o = {}
  } = n;
  r.accessToken = r.accessToken || e;
  const i = { bridge: t, apiOptions: r };
  let a = {};
  return s.forEach((l) => {
    a = { ...a, ...l(i) };
  }), t !== !1 && w(R), y = new g(o.schema), o.resolver && _(y, o.resolver), a;
}, _ = (n, t) => {
  n.addNode("blok", (e) => {
    let s = "";
    return e.attrs.body.forEach((r) => {
      s += t(r.component, r);
    }), {
      html: s
    };
  });
}, st = (n, t, e) => {
  let s = e || y;
  if (!s) {
    console.error(
      "Please initialize the Storyblok SDK before calling the renderRichText function"
    );
    return;
  }
  return n === "" ? "" : n ? (t && (s = new g(t.schema), t.resolver && _(s, t.resolver)), s.render(n)) : (console.warn(`${n} is not a valid Richtext object. This might be because the value of the richtext field is empty.
    
  For more info about the richtext object check https://github.com/storyblok/storyblok-js#rendering-rich-text`), "");
}, rt = () => w(R);
export {
  g as RichTextResolver,
  K as RichTextSchema,
  X as apiPlugin,
  rt as loadStoryblokBridge,
  tt as registerStoryblokBridge,
  st as renderRichText,
  Z as storyblokEditable,
  et as storyblokInit,
  tt as useStoryblokBridge
};
